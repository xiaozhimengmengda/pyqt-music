# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '网易云.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys
import os
import requests
import logging
from pyquery import PyQuery as pq
from PyQt5.QtWidgets import QApplication, QMainWindow,QMessageBox
from PyQt5 import QtCore, QtGui, QtWidgets

headers = {
    'Referer': 'https://music.163.com/',
    'Host': 'music.163.com',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.75 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
}
res = requests.session()

fmt ='%(asctime)s -[line:%(lineno)d] - %(levelname)s: %(message)s'
logging.basicConfig(level=logging.INFO, format=fmt)


def download(*args):
    try:
        path = os.getcwd()
        url, name = args
        r = res.get(url, stream=True)
        name = f"{name}.mp3"
        with open(f"{path}/{name}", "wb") as f:
            for chunk in r.iter_content(chunk_size=1024):
                if chunk:
                    f.write(chunk)
        return name

    except Exception as e:
        return e


class MyThread(QtCore.QThread):
    signal = QtCore.pyqtSignal(tuple)    # 括号里填写信号传递的参数

    def __init__(self):
        super().__init__()

    def set_task(self, tasks):
        self.tasks = tasks

    def __del__(self):
        # wait 是阻塞
        # quit 是退出
        self.wait()

    def run(self):
        # 进行任务操作
        """
        放置任务函数
        """
        logging.info(f"{self.tasks}")
        url, name = self.tasks
        names = download(url, name)
        self.signal.emit((names,))    # 发射信号


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1680, 1005)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setEnabled(True)
        self.tableWidget.setGeometry(QtCore.QRect(150, 271, 941, 601))
        self.tableWidget.setLineWidth(1)
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)

        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(170, 210, 112, 32))
        self.pushButton.setObjectName("pushButton")

        self.thread_pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.thread_pushButton.setGeometry(QtCore.QRect(800, 210, 112, 32))
        self.thread_pushButton.setObjectName("pushButton")

        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(290, 150, 411, 31))
        self.lineEdit.setObjectName("lineEdit")

        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(180, 160, 101, 16))
        self.label.setObjectName("label")

        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar.setGeometry(QtCore.QRect(160, 890, 921, 23))
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "开始采集"))
        self.thread_pushButton.setText(_translate("MainWindow", "批量下载"))
        self.label.setText(_translate("MainWindow", "网易云音乐地址"))


class Main(QMainWindow,Ui_MainWindow):

    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.table()
        self.thread = MyThread()
        # 添加开始采集的信号和槽,set_table
        self.pushButton.clicked.connect(self.set_table)
        # 多线程下载
        self.thread_pushButton.clicked.connect(self.thread_download)
        # 任务状态名字
        self.threads_status_name = []

    def table(self):
        self.tableWidget.setColumnCount(3)
        self.tableWidget.setRowCount(1)
        row = 0 # 行
        line = 0 # 列
        values = ["序号","歌曲名称","歌曲链接"]
        length = [50,200, 600]
        for line, content in enumerate(values):
            self.tableWidget.setItem(row, line, QtWidgets.QTableWidgetItem(content))#设置j行i列的内容为Value
            self.tableWidget.setColumnWidth(line,length[line]) #设置j列的宽度
            self.tableWidget.setRowHeight(row,50) #设置i行的高度

    def set_table(self):
        self.pushButton.setEnabled(False)
        items = self.spider()
        count = len(items.items())
        self.tableWidget.setRowCount(count+1)
        for num, item in enumerate(items):
            num = num + 1
            self.tableWidget.setItem(num, 0, QtWidgets.QTableWidgetItem(f"{num}"))
            self.tableWidget.setItem(num, 1, QtWidgets.QTableWidgetItem(item))#设置j行i列的内容为Value
            self.tableWidget.setItem(num, 2, QtWidgets.QTableWidgetItem(items[item]))#设置j行i列的内容为Value

        self.pushButton.setEnabled(True)
        # 允许右键产生菜单
        self.tableWidget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        # 将右键菜单绑定到槽函数generateMenu
        self.tableWidget.customContextMenuRequested.connect(self.generateMenu)
        # 双击事件
        self.tableWidget.doubleClicked.connect(self.display)

    def generateMenu(self,pos):
        # 添加按钮
        menu = QtWidgets.QMenu()
        menu.addAction('下载')
        menu.exec_(self.tableWidget.mapToGlobal(pos))

    def display(self):
        row_index = self.tableWidget.currentIndex().row()
        # 获取当前行Index
        url_current_row_name = self.tableWidget.item(row_index, 2).text()
        name_current_row_name = self.tableWidget.item(row_index, 1).text()
        # item(行,列), 获取当前行
        names = download(url_current_row_name, name_current_row_name)
        QMessageBox.information(self, '信息提示对话框',f'{names} 数据下载完成！')

    def spider(self):
        url=self.lineEdit.text().replace('/#/','/')
        response = res.get(url, headers=headers).content
        doc = pq(response)
        # with open("html.html") as f:
        #     doc = f.read()
        http = "http://music.163.com/song/media/outer/url"
        html = pq(doc)
        uls = html(".f-hide")("ul").items()
        results = [ur for ur in uls][0]
        names = {result.text():f"{http}{result.attr('href').replace('/song', '')}.mp3" for result in results("a").items()}
        return names


    def thread_download(self):

        self.thread_pushButton.setEnabled(False)
        rows = self.tableWidget.rowCount()# 获取当前表格共有多少行
        self.progressBar.maximum = rows
        self.tasks = rows - 1
        for item in range(1, rows):
            url_current_row_name = self.tableWidget.item(item, 2).text()
            name_current_row_name = self.tableWidget.item(item, 1).text()
            logging.info(f"{url_current_row_name, name_current_row_name}")
            # 回调 将多线程的返回值，交给回调函数处理
            self.thread = MyThread()
            self.thread.signal.connect(self.callback)
            self.thread.tasks = (url_current_row_name, name_current_row_name)
            self.thread.start()
            # 多线下载完成
            self.thread.finished.connect(self.threadFinished)
            # 更新进度条
            processbar = self.progressBar.value() + 1
            self.progressBar.setValue(processbar)

    def threadFinished(self):
        logging.info(f"{self.threads_status_name}")
        logging.info(f"{len(self.threads_status_name)},{self.tasks}")
        if len(self.threads_status_name) == self.tasks:
            self.thread_pushButton.setEnabled(True)
            QMessageBox.information(self, '信息提示对话框',f'数据下载完成！')
            self.progressBar.setValue(0)
            self.threads_status_name = []

    def callback(self, args):

        logging.info(args)
        self.threads_status_name.append(args)


if __name__=="__main__":
    # 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行
    app = QApplication(sys.argv)
    # 初始化
    myWin = Main()
    # 将窗口控件显示在屏幕上
    myWin.show()
    # 程序运行，sys.exit方法确保程序完整退出。
    sys.exit(app.exec_())
